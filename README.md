Entry Point: CartClient

Assumptions:
1. Over the time, this service is going to have the complex functionalities and not just the CRUD operations
2. Currency is INR
3. tax policy can change in future
4. duplicate product just sum up with existing product qty instead of duplicate entry in cart
5. cart is going be persisted
6. Validations:
    a. 0 <= cart size <= 50
    b. 0 <= qty/product <= 50
    c. invalid products are not allowed

Trade-offs:
1. Here use of DDD aggregate pattern has added some extra layer of abstraction and complexity as compare to the transaction script pattern but this trade off is worth when we look at the flexibility that it provides.

Out of scope / Future Enhancement:
1. Logging
2. Error Handling / Wrapper exception classed based on the business error type like DataNotFound,InvalidInput etc
3. Publishing domain events like CartCreated, ItemAdded, ItemQuantityUpdated etc
4. Persistence layer
5. Fetching value from configuration
6. Use of mapper class to map DTO to VO and vice versa

AI Tool Usage:
1. Specific Use Cases: Code generation based on prompt
2. Percentage of Code Generated by AI: ~80%
3. How AI-Generated Code Was Reviewed:
    a. Generated classes were reviewed by comparing the class diagram
    b. Making sure behaviour and states are meeting the expectations. e.g introducing Money value object over the simple Java field for storing the price
    c. Proper separation of concerns e.g tax is not hardcoded in cart service and it's dynamic with help of tax policy etc
    d. Quality and correctness is ensured with manual code review of logic as well as of test cases
    e. During review I have asked few questions to the generated code like does it really make sense? does it really belong here? Why is it in this way and not in other way? etc.
